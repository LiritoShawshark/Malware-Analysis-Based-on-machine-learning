import threading
import psutil
import socket
import os
import copy
import random
from scapy.all import *
from time import sleep
import pymysql
import numpy as np
import sys
import signal
import win32api


def get_host_ip():  # 获得本机ip地址
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(('8.8.8.8', 80))
        ip = s.getsockname()[0]
    finally:
        s.close()
    return ip


flow = {}  # 存储数据流
pid_flow = {}  # 存储流对应的pid
ip = get_host_ip()


def text_save(filename, data):  # filename为写入text文件的路径，data为要写入数据列表.
    file = open(filename, 'a')
    for i in range(len(data)):
        s = str(data[i]).replace('[', '').replace(']', '')  # 去除[],这两行按数据不同，可以选择
        s = s.replace("'", '').replace(',', '') + '   '  # 去除单引号，逗号，每行末尾追加三个空格
        file.write(s)
    file.write('\n')
    file.close()
    print("保存文件成功")


def load_str_tran(load_str):  # 统计数据中0,1 个数
    load_list = list(load_str)
    sum_1 = 0
    sum_0 = 0
    for i in load_list:
        sum_1 += ones(i)
        sum_0 += zeros(i)
    sum0_p = sum_0 / (sum_0 + sum_1)
    sum1_p = sum_1 / (sum_0 + sum_1)
    return sum_0, sum_1, sum0_p, sum1_p


def ones(num):
    return bin(num).count('1')


def zeros(num):
    return bin(num).count('0') - 1


def get_z_len(tcp_len_list):  # 获得中位数
    tcp_len_list.sort()
    lenght = len(tcp_len_list)
    if lenght >= 2:
        if lenght % 2 == 0:
            return (tcp_len_list[(lenght - 2) / 2] + tcp_len_list[lenght / 2]) / 2
        elif lenght % 2 == 1:
            return tcp_len_list[(lenght - 1) / 2]
    elif lenght == 1:
        return tcp_len_list[0]
    elif lenght == 0:
        return 0


def get_b_len(tcp_len_list):  # 求众数
    lenght = len(tcp_len_list)
    a_list = []
    a_dic = {}
    max = 0
    max_len = tcp_len_list[0]
    for a in tcp_len_list:
        if a not in a_list:
            a_dic[a] = 0
            a_list.append(a)
        else:
            a_dic[a] += 1
    for b in a_list:
        if a_dic[b] > max:
            max = a_dic[b]
            max_len = b
    return max_len


def kill(pid):  # 根据pid杀死进程
    try:
        a = os.kill(pid, signal.SIGKILL)
        # a = os.kill(pid, signal.9) #　与上等效
        print('kill %s successfully' % pid)
    except OSError as e:
        print("this process has already died")


def get_port_to_pid(port):  # 获得端口对应的进程pid和进程名
    report = str(port)
    # result=[]
    with os.popen('netstat -aon') as res:
        res = res.read().split('\n')

    for line in res:
        temp = [i for i in line.split(' ') if i != '']
        re_dic = {}
        if len(temp) > 4:
            if temp[1].split(':')[-1] == report:
                pid = temp[4]
                try:
                    with os.popen('tasklist|findstr ' + pid) as res2:
                        res2 = res2.read().split('\n')
                    exe_name = res2[0].split(' ')[0]

                except:
                    continue
                return temp[4], exe_name
            # result.append({'pid': temp[4], 'port': temp[1].split(':')[-1], 'state': temp[3]})

    return '1', 'error'


def is_end(pkts):
    if len(pkts) >= 2 and pkts[-1][TCP].flags == 'A' and pkts[-2][TCP].flags == 'FA':
        return True
    elif pkts[-1][TCP].flags == 'R' or pkts[-1][TCP].flags == 'RA':
        return True
    else:
        return False


def pcap_select(pkts2, re_list, port_list):  # 数据包筛选函数 将目的进程的数据筛选出来并提取特征值

    re_pid = re_list[0]
    exe_name = re_list[1]

    lenght = len(pkts2)

    s_flag = 0  # 判断会话流的flag

    sum_len_src = 0  # tcp出去的长度
    sum_len_dst = 0  # tcp进来的长度

    load_len_src = 0  # 发送的数据长度
    load_len_dst = 0  # 接受的数据长度

    tcp_num_src = 0  # 发送的包数量
    tcp_num_dst = 0  # 接受的包数量
    tcp_num_sum = 0  # 总的数据包

    load_num_src = 0  # 发送的数据
    load_num_dst = 0  # 接受的数
    load_num_sum = 0  # 数据总量

    max_len_src = 0  # 最大发送的包
    min_len_src = 99999999  # 最小发送的包
    max_len_dst = 0  # 最大接受的包
    min_len_dst = 99999999  # 最小接受的包

    p_len_src = 0.0  # 出去长度平均值
    p_len_dst = 0.0  # 进来长度平均值
    z_len_src = 0  # 出去长度中位数
    z_len_dst = 0  # 进来长度中位数
    b_len_src = 0  # 众数
    b_len_dst = 0  # 众数
    d_len_src = 0.0  # 发送包标准差
    d_len_dst = 0.0  # 接受包标准差

    # load的各种统计特征
    load_p_len_src = 0.0  # 出去长度平均值
    load_p_len_dst = 0.0  # 进来长度平均值
    load_z_len_src = 0  # 出去长度中位数
    load_z_len_dst = 0  # 进来长度中位数
    load_b_len_src = 0  # 众数
    load_b_len_dst = 0  # 众数
    load_d_len_src = 0.0  # 发送包标准差
    load_d_len_dst = 0.0  # 接受包标准差

    load_len_src_list = []
    load_len_dst_list = []
    sum_len_src_list = []  # 发送的数据包长度列表
    sum_len_dst_list = []  # 接受的数据包长度列表

    # 前三个数据包中数据段0，1数量
    f_len_1 = 0
    f_len_0 = 0
    s_len_1 = 0
    s_len_0 = 0
    t_len_1 = 0
    t_len_0 = 0

    f_len_1_p = 0.0
    f_len_0_p = 0.0
    s_len_1_p = 0.0
    s_len_0_p = 0.0
    t_len_1_p = 0.0
    t_len_0_p = 0.0

    # 时间信息
    start_time = 0
    end_time = 0
    p_time = 0.0
    sum_time = 0

    load_flag = 0

    re_list = []  # 用于存放最后的结果
    ip = get_host_ip()
    for i in range(lenght):
        if lenght <= 2:
            break
        try:
            # pkts2[i].show()
            if i == 0:
                start_time = pkts2[i].time
            IP_src = pkts2[i].payload.src  # 源ip
            IP_dst = pkts2[i].payload.dst  # 目的ip

            src_port = pkts2[i][TCP].sport  # 源端口
            dst_port = pkts2[i][TCP].dport  # 目的端口

            # 数据统计部分 每个会话内的数据包都会被统计
            # 统计前三个包中的load 1，0个数 同时记录load长度
            try:
                load_len = len(pkts2[i][Raw].load)
                if load_flag < 3:
                    load_str = pkts2[i][Raw].load
                    # print(load_str)
                    sum_0, sum_1, sum_0_p, sum_1_p = load_str_tran(load_str)
                    if load_flag == 0:
                        f_len_0 += sum_0
                        f_len_1 += sum_1
                        f_len_0_p += sum_0_p
                        f_len_1_p += sum_1_p
                    elif load_flag == 1:
                        s_len_0 += sum_0
                        s_len_1 += sum_1
                        s_len_0_p += sum_0_p
                        s_len_1_p += sum_1_p
                    elif load_flag == 2:
                        t_len_0 += sum_0
                        t_len_1 += sum_1
                        t_len_0_p += sum_0_p
                        t_len_1_p += sum_1_p
                    load_flag += 1

            except Exception as e:
                load_len = 0

            # 统计数据包长度
            a_tcp_len = len(pkts2[i])  # tcp包长度

            if IP_src == ip:  # 标志数据包方向 0为出 1为入 判断数据流方向
                tcp_num_src += 1

                sum_len_src += a_tcp_len
                sum_len_src_list.append(a_tcp_len)

                if a_tcp_len > max_len_src:
                    max_len_src = a_tcp_len
                if a_tcp_len < min_len_src:
                    min_len_src = a_tcp_len

                if load_len:
                    load_num_src += 1
                    load_len_src += load_len
                    load_len_src_list.append(load_len)
                trandir = 0

            elif IP_dst == ip:
                tcp_num_dst += 1

                sum_len_dst += a_tcp_len
                sum_len_dst_list.append(a_tcp_len)

                if a_tcp_len > max_len_dst:
                    max_len_dst = a_tcp_len
                if a_tcp_len < min_len_dst:
                    min_len_dst = a_tcp_len

                if load_len:
                    load_num_dst += 1
                    load_b_len_dst += load_len
                    load_len_dst_list.append(load_len)
                trandir = 1

            else:
                break

            if i == lenght - 1:  # 最后一个数据包 开始计算
                # print("the tcp connect end")
                tcp_num_sum = tcp_num_dst + tcp_num_src
                end_time = pkts2[i].time  # 结束时间3
                sum_time = end_time - start_time
                if tcp_num_sum:
                    p_time = sum_time / tcp_num_sum
                # 计算发送的数据包平均数众数等统计信息
                if tcp_num_dst:
                    p_len_src = sum_len_src / tcp_num_src
                    z_len_src = np.median(sum_len_src_list)
                    b_len_src = get_b_len(sum_len_src_list)
                    d_len_src = np.std(sum_len_src_list, ddof=0)
                if load_num_src:
                    load_p_len_src = load_len_src / load_num_src
                    load_z_len_src = np.median(load_len_src_list)
                    load_b_len_src = get_b_len(load_len_src_list)
                    load_d_len_src = np.std(load_len_src_list, ddof=0)

                # 计算接受的数据包平均数众数等统计信息
                if tcp_num_dst:
                    p_len_dst = sum_len_dst / tcp_num_dst  # 平均数
                    z_len_dst = np.median(sum_len_dst_list)  # 中位数
                    b_len_dst = get_b_len(sum_len_dst_list)  # 众数
                    d_len_dst = np.std(sum_len_dst_list, ddof=0)  # 方差

                if load_num_dst:
                    load_p_len_dst = load_len_dst / load_num_dst
                    load_z_len_dst = np.median(load_len_dst_list)
                    load_b_len_dst = get_b_len(load_len_dst_list)
                    load_d_len_dst = np.std(load_len_dst_list, ddof=0)

                re_list = [src_port, dst_port, tcp_num_sum, tcp_num_src, tcp_num_dst, sum_len_src, sum_len_dst,
                           load_len_src, load_len_dst, max_len_src, min_len_src, max_len_dst, min_len_dst,
                           p_len_src, p_len_dst, z_len_src, z_len_dst, b_len_src, b_len_dst, d_len_src, d_len_dst,
                           load_p_len_src, load_p_len_dst, load_z_len_src, load_z_len_dst, load_b_len_src,
                           load_b_len_dst, load_d_len_src, load_d_len_dst,
                           f_len_0, f_len_1, f_len_0_p, f_len_1_p, s_len_0, s_len_1, s_len_0_p, s_len_1_p, t_len_0,
                           t_len_1, t_len_0_p, t_len_1_p,
                           sum_time, p_time
                           ]

                filename = "sniff\\" + re_pid + exe_name + ".txt"  # 存储目录
                text_save(filename, re_list)
                break

        except Exception as e:
            # print(e)
            # print(re_list)
            continue


def pcap_sniff(pkt):  # sniff回调函数 用于处理抓到的包
    global flow
    global pid_flow
    global ip

    if 'TCP' in pkt:

        a_list = []
        try:
            IP_src = pkt.payload.src  # 源ip
            IP_dst = pkt.payload.dst  # 目的ip
            src_port = pkt.payload.payload.sport
            dst_port = pkt.payload.payload.dport

            if IP_src > IP_dst:
                a_list.append(IP_src)
                a_list.append(IP_dst)
            else:
                a_list.append(IP_dst)
                a_list.append(IP_src)
            if src_port >= dst_port:
                a_list.append(src_port)
                a_list.append(dst_port)
            else:
                a_list.append(dst_port)
                a_list.append(src_port)

            if len(a_list) == 4:
                a_tuple = tuple(a_list)

                if a_tuple in flow.keys():  # 数据流已经存在
                    # print(get a new pcap)
                    flow[a_tuple].append(pkt)
                    if is_end(flow[a_tuple]):  # 判断数据流是否结束
                        print("start end the flow from " + pid_flow[a_tuple][1] + ' ' + pid_flow[a_tuple][0])
                        pcap_select(flow[a_tuple], pid_flow[a_tuple], a_list)  # 如果结束则从数据流中提取特征值
                        flow.pop(a_tuple)

                else:  # 数据流不存在 则新建一个
                    if pkt[TCP].flags != 'FA' and pkt[TCP].flags != 'R' and pkt[TCP].flags != 'RA':  # 如果只抓到了结束的包没有意义过滤掉
                        if IP_src == ip:
                            se_port = src_port
                        else:
                            se_port = dst_port
                        re_pid, exe_name = get_port_to_pid(se_port)
                        if exe_name != 'error':
                            print("get a new flow from " + exe_name + ' ' + re_pid)
                        flow[a_tuple] = []
                        flow[a_tuple].append(pkt)
                        pid_flow[a_tuple] = [re_pid, exe_name]
            else:
                pass

        except Exception as e:
            # pkts[i].show()
            # print(pkts[i].type)#type 34525 对应ipv6
            # print(e)
            pass


def make_save_dir():  # 创建存储用的文件夹
    try:
        save_dir = os.getcwd() + '\\sniff'
        if not os.path.exists(save_dir):
            os.mkdir(save_dir)
        return True
    except:
        return False


def main():
    global ip
    if make_save_dir():
        print("start to monitor the network ")
        pkts = sniff(prn=pcap_sniff, filter="host " + str(ip) + " and tcp")


if __name__ == '__main__':
    main()
